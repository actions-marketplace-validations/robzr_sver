#!/usr/bin/env sver_execed=true /bin/bash -eo pipefail
# shellcheck disable=SC1008,SC2096,SC2015
# shfmt -i 2 -ci -w

SVER_VERSION=v0.0.1
SVER_INTRO="\
sver ${SVER_VERSION} (https://github.com/robzr/sver) self contained cli tool and function
library implementing a Semantic Versioning 2 compliant parser and utilities.
Written in optimized, portable, pure bash for simplicity & speed.
"

# regex from https://semver.org - removed PCRE named capture groups, added ^v?
SVER_REGEX='^v?(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(-((0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(\.(0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(\+([0-9a-zA-Z-]+(\.[0-9a-zA-Z-]+)*))?$'

#
# All functions are reusable and use the same syntax as the CLI. The CLI is a
# thin shim over the functions - see end of file.
#
# Unless otherwise noted, function arguments are $1 == version, and strings are
# returned via the $RETURN variable wherever practical in order to eliminate an
# unnecessary child process. Even the sort routine is written in pure bash.
#
unset -v RETURN
RETURN=

_sver_complete_function() {
  #echo ":::${COMP_CWORD} in ${COMP_WORDS[@]} (${COMP_WORDS[$COMP_CWORD]}):::" >&2
  if [ "$COMP_CWORD" = 1 ]; then
    # shellcheck disable=SC2046
    read -ra COMPREPLY <<<$(compgen -W \
      "bump complete constraint equals filter get greater_than help json less_than sort validate version yaml" \
      "${COMP_WORDS[1]}" || true)
  elif [ "$COMP_CWORD" = 2 ]; then
    case "${COMP_WORDS[1]}" in
      bump)
        # shellcheck disable=SC2046
        read -ra COMPREPLY <<<$(compgen -W "major minor patch" "${COMP_WORDS[2]}" || true)
        ;;
      get)
        # shellcheck disable=SC2046
        read -ra COMPREPLY <<<$(compgen -W \
          "build_metadata major minor patch prerelease" "${COMP_WORDS[2]}" || true)
        ;;
      *)
        COMPREPLY=()
        ;;
    esac
  fi
}

sver_bump_major() {
  sver_get_major "$1"
  RETURN="$((RETURN + 1)).0.0"
}

sver_bump_minor() {
  local major
  sver_get_major "$1"
  major=$RETURN
  sver_get_minor "$1"
  RETURN="${major}.$((RETURN + 1)).0"
}

sver_bump_patch() {
  local major minor
  sver_get_major "$1"
  major=$RETURN
  sver_get_minor "$1"
  minor=$RETURN
  sver_get_patch "$1"
  RETURN="${major}.${minor}.$((RETURN + 1))"
}

sver_complete() {
  RETURN=
  declare -f _sver_complete_function
  echo complete -F _sver_complete_function sver
}

sver_constraint() { # $1=version $2=constraint(s); if matches returns 0 else 1
  # Evaluates whether version matches constraint(s). Multiple constraints can
  # be comma separated and will be valuated with boolean AND logic. Syntax is
  # whitespace-agnostic and matches other commonly used constraint syntax:
  #   =  <version>  - equals (build metadata is not considered as per spec)
  #   != <version>  - not equals
  #   >  <version>  - standard comparisons
  #   >= <version>  - standard comparisons
  #   <  <version>  - standard comparisons
  #   <= <version>  - standard comparisons
  #   ~> <sub_version>  - pessimistic constraint operator
  local return_status=0
  local constraint constraints operator tmp value
  sver_normalize -b "$1"
  local version=$RETURN
  shift
  IFS=, read -ra constraints <<<"$@"
  for constraint in "${constraints[@]}"; do
    operator=${constraint//[^!=<>~]/}
    value=${constraint//[^0-9.]/}
    echo "version:${version}: constraint:${constraint}: operator:${operator}: value:${value}:"
    if [ "$operator" = "=" ]; then
      if ! sver_equals "$version" "$value"; then
        return_status=1
      fi
    elif [ "$operator" = "!=" ]; then
      if sver_equals "$version" "$value"; then
        return_status=1
      fi
    elif [ "$operator" = ">" ]; then
      if ! sver_greater_than "$version" "$value"; then
        return_status=1
      fi
    elif [ "$operator" = ">=" ]; then
      if ! sver_greater_than "$version" "$value" && ! sver_equals "$version" "$value"; then
        return_status=1
      fi
    elif [ "$operator" = "<" ]; then
      if ! sver_less_than "$version" "$value"; then
        return_status=1
      fi
    elif [ "$operator" = "<=" ]; then
      if ! sver_less_than "$version" "$value" && ! sver_equals "$version" "$value"; then
        return_status=1
      fi
    elif [ "$operator" = "~>" ]; then
      sver_get_major "$version"
      local version_major=$RETURN
      sver_get_minor "$version"
      local version_minor=$RETURN
      sver_get_patch "$version"
      local version_patch=$RETURN
      sver_get_major "$value"
      local value_major=$RETURN
      sver_get_minor "$value"
      local value_minor=$RETURN
      sver_get_patch "$value"
      local value_patch=$RETURN
      if [[ "$value" =~ ^[^.]+\.[^.]+\.[^.]+ ]]; then # floating patch
        if [ "$version_major" -ne "$value_major" ] ||
          [ "$version_minor" -ne "$value_minor" ] ||
          [ "$version_patch" -lt "$value_patch" ]; then
          return_status=1
        fi
      elif [[ "$value" =~ ^[^.]+\.[^.]+ ]]; then # floating minor
        if [ "$version_major" -ne "$value_major" ] ||
          [ "$version_minor" -lt "$value_minor" ]; then
          return_status=1
        fi
      elif [[ "$value" =~ ^[^.]+\.[^.]+ ]]; then # floating major
        if [ "$version_major" -lt "$value_major" ]; then
          return_status=1
        fi
      fi
    else
      echo "Error: Invalid operator (${operator})." >&2
      return 1
    fi
  done
  RETURN=
  return $return_status
}

sver_equals() { # if $1 == $2 then return 0 else return 1
  sver_normalize -b "$1"
  local version1=$RETURN
  sver_normalize -b "$2"
  local version2=$RETURN
  RETURN=
  [ "$version1" = "$version2" ]
}

sver_filter() { # no args, input & output are \n delimited SemVers on stdin
  local line
  while read -r line; do
    if sver_validate "$line"; then
      echo "$line"
    fi
  done
  RETURN=
}

sver_get_build_metadata() {
  RETURN=${1#*+}
  if [ "$RETURN" = "$1" ]; then
    RETURN=
  fi
  RETURN=${RETURN%+*}
}

sver_get_major() {
  local words
  IFS=. read -ra words <<<"$1"
  RETURN=${words[0]#v}
}

sver_get_minor() {
  local words
  IFS=. read -ra words <<<"$1"
  RETURN=${words[1]}
  if [ -z "$RETURN" ]; then
    RETURN=0
  fi
}

sver_get_patch() {
  local words
  IFS=. read -ra words <<<"$1"
  RETURN=${words[2]/[a-zA-Z+-]*/}
  if [ -z "$RETURN" ]; then
    RETURN=0
  fi
}

sver_get_prerelease() {
  RETURN=${1%+*}
  RETURN=${RETURN#*-}
  if [ "$RETURN" = "${1%+*}" ]; then
    RETURN=
  fi
}

sver_greater_than() { # if $1 > $2 then return 0 else return 1
  sver_normalize -b "$1"
  local version1=$RETURN
  sver_normalize -b "$2"
  local version2=$RETURN
  local id1 id2 pr1 pr2
  sver_get_major "$version1"
  id1=$RETURN
  sver_get_major "$version2"
  id2=$RETURN
  [ "$id1" -gt "$id2" ] && return 0 || true
  [ "$id1" -lt "$id2" ] && return 1 || true
  sver_get_minor "$version1"
  id1=$RETURN
  sver_get_minor "$version2"
  id2=$RETURN
  [ "$id1" -gt "$id2" ] && return 0 || true
  [ "$id1" -lt "$id2" ] && return 1 || true
  sver_get_patch "$version1"
  id1=$RETURN
  sver_get_patch "$version2"
  id2=$RETURN
  [ "$id1" -gt "$id2" ] && return 0 || true
  [ "$id1" -lt "$id2" ] && return 1 || true
  sver_get_prerelease "$version1"
  pr1=$RETURN
  sver_get_prerelease "$version2"
  pr2=$RETURN
  [[ -z "$pr1" && -n "$pr2" ]] && return 0 || true
  [[ -n "$pr1" && -z "$pr2" ]] && return 1 || true
  while [[ -n "$pr1" || -n "$pr2" ]]; do
    id1=${pr1%%.*}
    id2=${pr2%%.*}
    pr1=${pr1#*.}
    pr2=${pr2#*.}
    [ "$pr1" = "$id1" ] && pr1=
    [ "$pr2" = "$id2" ] && pr2=
    [[ -n "$id1" && -z "$id2" ]] && return 0 || true
    [[ -z "$id1" && -n "$id2" ]] && return 1 || true
    [[ -z "$id1" && -z "$id2" ]] && return 1 || true
    if [[ "$id1" =~ ^[0-9]*$ && "$id1" =~ ^[0-9]*$ ]]; then
      [ "$id1" -gt "$id2" ] && return 0 || true
      [ "$id1" -lt "$id2" ] && return 1 || true
    else
      [[ "$id1" > "$id2" ]] && return 0 || true
      [[ "$id1" < "$id2" ]] && return 1 || true
    fi
  done
  return 1
}

sver_help() {
  cat <<-_EOF_
	${SVER_INTRO}
	Usage: sver <command> [<sub_command>] [<version>] [<constraint>]

	Commands:
	  bump major <version>
	  bump minor <version>
	  bump patch <version>
	  complete -- bash command completion, use: . /dev/stdin <<< "\$(sver complete)"
	  constraint <version> <constraint(s)> -- version constraint evaluation - if
	                              version matches constraint(s), exit 0 else exit 1
	  yaml <version> -- displays YAML map of components
	  equals <version1> <version2> -- if version1 == version2, exit 0 else exit 1
	  filter -- filters stdin list, returns only valid SemVers
	  greater_than <version1> <version2> -- version1 > version2, exit 0 else exit 1
	  get major <version>
	  get minor <version>
	  get patch <version>
	  get prerelease <version>
	  get build_metadata <version>
	  help
	  sort -- sorts stdin list of SemVers
	  validate <version> -- if version is valid, exit 0 else exit 1
	  version

	Versions:
	  Semantic Versioning 2 (https://semver.org) compliant versions, with an
	  optional "v" prefix tolerated on input.

	Constraints:
	  Version constraint supports the following operators. Multiple comma-delimited
	  constraints can be used. Abbreviated version substrings can be used, and are
	  especially useful with pessimistic constraint.
	    = <version_substring> -- equal
	    > <version_substring> -- greater than
	    >= <version_substring> -- greater than or equal to
	    < <version_substring> -- less than
	    <= <version_substring> -- less than or equal to
	    ~> <version_substring> -- pessimistic constraint operator, allows the least
	      significant (rightmost) identifier specified in the constraint to be
	      incremented, but prevents more significant (further left) identifiers
	      from being incremented.
	_EOF_
}

sver_json() {
  sver_normalize "$1"
  local version=$RETURN
  echo '{'
  echo "  \"version\": \"${version}\","
  sver_get_major "$version"
  echo "  \"major\": \"${RETURN}\","
  sver_get_minor "$version"
  echo "  \"minor\": \"${RETURN}\","
  sver_get_patch "$version"
  echo "  \"patch\": \"${RETURN}\","
  sver_get_prerelease "$version"
  echo "  \"prerelease\": \"${RETURN}\","
  sver_get_build_metadata "$version"
  echo "  \"build_metadata\": \"${RETURN}\""
  echo '}'
  RETURN=
}

sver_less_than() { # if $1 < $2 then return 0 else return 1
  sver_greater_than "$2" "$1"
}

sver_normalize() {
  local version_return
  local keep_build_metadata=true
  if [ "$1" = "-b" ]; then
    keep_build_metadata=false
    shift
  fi
  local version=${1#v}
  sver_get_major "$version"
  version_return=$RETURN
  sver_get_minor "$version"
  version_return="${version_return}.${RETURN}"
  sver_get_patch "$version"
  version_return="${version_return}.${RETURN}"
  sver_get_prerelease "$version"
  if [ -n "$RETURN" ]; then
    version_return="${version_return}-${RETURN}"
  fi
  if $keep_build_metadata; then
    sver_get_build_metadata "$version"
    if [ -n "$RETURN" ]; then
      version_return="${version_return}+${RETURN}"
    fi
  fi
  RETURN=$version_return
}

sver_sort() { # no arg, input is list of semvers, output is via stdout
  local i j swapped tmp versions

  # shellcheck disable=SC2046
  read -ra versions <<<$(sver_filter | xargs echo)
  # bubble sort
  for ((i = 0; i < ${#versions[@]} - 1; i++)); do
    swapped=false
    for ((j = 0; j < ${#versions[@]} - 1 - i; j++)); do
      if sver_greater_than "${versions[$j]}" "${versions[$((j + 1))]}"; then
        tmp=${versions[$((j + 1))]}
        versions[j + 1]=${versions[$j]}
        versions[j]=$tmp
        swapped=true
      fi
    done
    $swapped || break
  done

  tmp=$IFS
  IFS="
"
  echo "${versions[*]}"
  IFS=$tmp
  RETURN=
}

sver_validate() {
  RETURN=
  [[ "$1" =~ $SVER_REGEX ]]
}

sver_version() {
  RETURN="$SVER_VERSION"
}

sver_yaml() {
  sver_normalize "$1"
  local version=$RETURN
  echo "version: ${version}"
  sver_get_major "$version"
  echo "major: $RETURN"
  sver_get_minor "$version"
  echo "minor: $RETURN"
  sver_get_patch "$version"
  echo "patch: $RETURN"
  sver_get_prerelease "$version"
  echo "prerelease: $RETURN"
  sver_get_build_metadata "$version"
  echo "build_metadata: $RETURN"
  RETURN=
}

# CLI handler; translates CLI args to function calls when used in CLI mode
#
# Instead of hardcoding a mapping of CLI args => functions, leverage the
# existing command completion function to allow for abbreviated commands
# with comprehensive validation and meaningful error messages & hints.
# - `sver b ma v1.2.3` expands to `sver bump major v1.2.3`
# - `sver b m v1.2.3` meaningfully errors due to ambiguous 'm'
#
# shellcheck disable=SC2154
if [ "$sver_execed" = true ]; then
  unset command
  if [ $# = 0 ]; then
    COMP_WORDS=("" "help")
  else
    COMP_WORDS=("" "${@}")
  fi
  COMP_CWORD=1
  _sver_complete_function
  if [ "${#COMPREPLY[@]}" == 1 ]; then
    shift || true
    command=${COMPREPLY[0]}
  else
    if [ "${#COMPREPLY[@]}" == 0 ]; then
      echo "Error: Unknown command (${COMP_WORDS[1]}), run \"sver help\" for usage." >&2
    else
      echo "Error: Ambiguous command (possibilities: [${COMPREPLY[*]}])." >&2
    fi
    exit 1
  fi
  if [ "$command" = "get" ] || [ "$command" = "bump" ]; then
    COMP_WORDS=("" "$command" "${@}")
    COMP_CWORD=2
    shift || true
    _sver_complete_function
    if [ "${#COMPREPLY[@]}" == 1 ]; then
      command="${command}_${COMPREPLY[0]}"
    else
      if [ "${#COMPREPLY[@]}" == 0 ]; then
        echo "Error: Unknown subcommand (${command} ${COMP_WORDS[2]}), run \"sver help\" for usage." >&2
      else
        echo "Error: Ambiguous subcommand (possibilities: ${command} [${COMPREPLY[*]}])." >&2
      fi
      exit 1
    fi
  fi
  case "$command" in
    bump_* | constraint | get_* | greater_than | json | less_than | yaml)
      if ! sver_validate "$1"; then
        echo "Error: Invalid semver specified (${1})." >&2
        exit 1
      fi
      ;;
  esac
  case "$command" in
    equals | greater_than | less_than)
      if ! sver_validate "$2"; then
        echo "Error: Invalid semver specified (${2})." >&2
        exit 1
      fi
      ;;
  esac

  status=0
  "sver_${command}" "${@}" || status=$?

  if [ -n "$RETURN" ]; then
    echo "$RETURN"
  fi
  exit $status
fi
