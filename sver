#!/usr/bin/env sver_execed=true /bin/bash #-eo pipefail 
#set -x

SVER_VERSION=v0.0.1
SVER_INTRO="\
sver ${SVER_VERSION} (https://github.com/robzr/sver) Self contained cli tool and function
library implementing a Semantic Versioning 2 compliant parser and utilities.
Written in optimized, portable, pure bash for simplicity & speed.
"

# regex from https://semver.org - removed PCRE named capture groups, added ^v?
SVER_REGEX='^v?(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(-((0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(\.(0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(\+([0-9a-zA-Z-]+(\.[0-9a-zA-Z-]+)*))?$'

unset -v RETURN
RETURN=

#
# All functions are reusable and use the same syntax as the CLI. The CLI is a
# thin shim over the functions - see end of file.
#
# Unless otherwise noted, function arguments are $1 == version, and strings are
# returned via the $RETURN variable wherever practical in order to eliminate an
# unnecessary child process. Even the sort routine is written in pure bash.
#

_sver_complete_function() {
  #echo ":::${COMP_CWORD} in ${COMP_WORDS[@]} (${COMP_WORDS[$COMP_CWORD]}):::" >&2

  if [ "$COMP_CWORD" = 1 ] ; then
    COMPREPLY=($(compgen -W "bump complete constraint equals filter get greater_than help json sort validate version yaml" "${COMP_WORDS[1]}" || true))
  elif [ "$COMP_CWORD" = 2 ] ; then
    case "${COMP_WORDS[1]}" in
      bump)
        COMPREPLY=($(compgen -W "major minor patch" "${COMP_WORDS[2]}" || true))
        ;;
      get)
        COMPREPLY=($(compgen -W "build_metadata major minor patch prerelease" "${COMP_WORDS[2]}" || true))
        ;;
      *)
        COMPREPLY=()
        ;;
    esac
  fi
}

sver_bump_major() {
  sver_get_major "$1"
  RETURN="$((RETURN + 1)).0.0"
}

sver_bump_minor() {
  local major
  sver_get_major "$1" ; major=$RETURN
  sver_get_minor "$1"
  RETURN="${major}.$((RETURN + 1)).0"
}

sver_bump_patch() {
  local major minor
  sver_get_major "$1" ; major=$RETURN
  sver_get_minor "$1" ; minor=$RETURN
  sver_get_patch "$1"
  RETURN="${major}.${minor}.$((RETURN + 1))"
}

sver_complete() {
  RETURN=
  declare -f _sver_complete_function
  echo complete -F _sver_complete_function sver
}

sver_constraint() { # $1=version $2=constraint(s); if matches returns 0 else 1
  # Evaluates whether version matches constraint(s). Multiple constraints can
  # be comma separated and will be valuated with boolean AND logic. Syntax is
  # whitespace-agnostic and matches other commonly used constraint syntax:
  #   =  <version>  - equals (build metadata is not considered as per spec)
  #   != <version>  - not equals
  #   >  <version>  - standard comparisons
  #   >= <version>  - standard comparisons
  #   <  <version>  - standard comparisons
  #   <= <version>  - standard comparisons
  #   ~> <sub_version>  - pessimistic constraint operator
  local return_status=0
  local constraint constraints operator tmp value
  local version=${1#v}
  version=${version%+*}
  shift
  IFS=, read -a constraints <<< "$@"
  for constraint in "${constraints[@]}" ; do
    operator=${constraint//[^!=<>~]/}
    value=${constraint//[^0-9.]/}
    echo "version:${version}: constraint:${constraint}: operator:${operator}: value:${value}:"
    if [ "$operator" = "=" ] ; then
      if sver_equals "$version" "$value" ; then
        return_status=1
      fi
    elif [ "$operator" = "!=" ] ; then
      if ! sver_equals "$version" "$value" ; then
        return_status=1
      fi
    elif [ "$operator" = ">" ] ; then
      if ! sver_greater_than "$version" "$value" ; then
        return_status=1
      fi
    elif [ "$operator" = ">" ] ; then
      if ! sver_greater_than "$version" "$value" ; then
        return_status=1
      fi
    elif [ "$operator" = "<" ] ; then
      if ! sver_greater_than "$value" "$version" ; then
        return_status=1
      fi
    elif [ "$operator" = ">=" ] ; then
      if ! sver_greater_than "$version" "$value" || ! sver_equals "$version" "$value" ; then
        return_status=1
      fi
    elif [ "$operator" = "<=" ] ; then
      if ! sver_greater_than "$value" "$version" || ! sver_equals "$version" "$value" ; then
        return_status=1
      fi
    elif [ "$operator" = "~>" ] ; then
      : 
    else
      echo "Error: Invalid operator (${operator})."
      return 1
    fi
  done
  RETURN=
  return $return_status
}

sver_equals() { # if $1 == $2 then return 0 else return 1
  local version1=${1#v}
  local version2=${2#v}
  version1=${version1%+*}
  version2=${version2%+*}
  RETURN=
  [ "$version1" = "$version2" ]
}

sver_filter() { # no args, input & output are \n delimited SemVers on stdin
  local line
  while read line ; do
    if sver_validate "$line" ; then
      echo "$line"
    fi
  done
  RETURN=
}

sver_get_build_metadata() {
  RETURN=${1#*+}
  if [ "$RETURN" = "$1" ] ; then
    RETURN=
  fi
  RETURN=${RETURN%+*}
}

sver_get_major() {
  local words
  IFS=. read -a words <<< "$1"
  RETURN=${words[0]#v}
}

sver_get_minor() {
  local words
  IFS=. read -a words <<< "$1"
  RETURN=${words[1]}
  if [ -z "$RETURN" ] ; then
    RETURN=0
  fi
}

sver_get_patch() {
  local words
  IFS=. read -a words <<< "$1"
  RETURN=${words[2]/[a-zA-Z+-]*/}
  if [ -z "$RETURN" ] ; then
    RETURN=0
  fi
}

sver_get_prerelease() {
  RETURN=${1%+*}
  RETURN=${RETURN#*-}
  if [ "$RETURN" = "${1%+*}" ] ; then
    RETURN=
  fi
}

sver_greater_than() { # if $1 > $2 then return 0 else return 1
  local version1=${1#v}
  local version2=${2#v}
  local id1 id2 pr1 pr2
  sver_get_major "$version1" ; id1=$RETURN
  sver_get_major "$version2" ; id2=$RETURN
  [ "$id1" -gt "$id2" ] && return 0 || true
  [ "$id1" -lt "$id2" ] && return 1 || true
  sver_get_minor "$version1" ; id1=$RETURN
  sver_get_minor "$version2" ; id2=$RETURN
  [ "$id1" -gt "$id2" ] && return 0 || true
  [ "$id1" -lt "$id2" ] && return 1 || true
  sver_get_patch "$version1" ; id1=$RETURN
  sver_get_patch "$version2" ; id2=$RETURN
  [ "$id1" -gt "$id2" ] && return 0 || true
  [ "$id1" -lt "$id2" ] && return 1 || true
  sver_get_prerelease "$version1" ; pr1=$RETURN
  sver_get_prerelease "$version2" ; pr2=$RETURN
  [[ -z "$pr1" && -n "$pr2" ]] && return 0 || true
  [[ -n "$pr1" && -z "$pr2" ]] && return 1 || true
  while [[ -n "$pr1" || -n "$pr2" ]] ; do
    id1=${pr1%%.*}
    id2=${pr2%%.*}
    pr1=${pr1#*.}
    pr2=${pr2#*.}
    [ "$pr1" = "$id1" ] && pr1= 
    [ "$pr2" = "$id2" ] && pr2= 
    [[ -n "$id1" && -z "$id2" ]] && return 0 || true
    [[ -z "$id1" && -n "$id2" ]] && return 1 || true
    [[ -z "$id1" && -z "$id2" ]] && return 1 || true
    if [[ "$id1" =~ ^[0-9]*$ && "$id1" =~ ^[0-9]*$ ]] ; then
      [ "$id1" -gt "$id2" ] && return 0 || true
      [ "$id1" -lt "$id2" ] && return 1 || true
    else
      [[ "$id1" > "$id2" ]] && return 0 || true
      [[ "$id1" < "$id2" ]] && return 1 || true
    fi
  done
  return 1
}

sver_help() {
      cat <<-_EOF_
	${SVER_INTRO}
	Usage: sver <command> [<sub_command>] [<version>] [<constraint>]

	Commands:
	  bump major <version>
	  bump minor <version>
	  bump patch <version>
	  complete -- bash command completion, use: . /dev/stdin <<< "\$($0 complete)"
	  constraint <version> <constraint(s)> -- version constraint evaluation - if
	                              version matches constraint(s), exit 0 else exit 1
	  yaml <version> -- displays YAML map of components
	  equals <version1> <version2> -- if version1 == version2, exit 0 else exit 1
	  filter -- filters stdin list, returns only valid SemVers
	  greater_than <version1> <version2> -- version1 > version2, exit 0 else exit 1
	  get major <version>
	  get minor <version>
	  get patch <version>
	  get prerelease <version>
	  get build_metadata <version>
	  help
	  sort -- sorts stdin list of SemVers
	  validate <version> -- if version is valid, exit 0 else exit 1
	  version

	Versions:
	  Semantic Versioning 2 (https://semver.org) compliant versions, with an
	  optional "v" prefix tolerated on input.

	Constraints:
	  Version constraint supports the following operators. Multiple comma-delimited
	  constraints can be used. Abbreviated version substrings can be used, and are
	  especially useful with pessimistic constraint.
	    = <version_substring> -- equal
	    > <version_substring> -- greater than
	    >= <version_substring> -- greater than or equal to
	    < <version_substring> -- less than
	    <= <version_substring> -- less than or equal to
	    ~> <version_substring> -- pessimistic constraint operator, allows the least
	      significant (rightmost) identifier specified in the constraint to be
	      incremented, but prevents more significant (further left) identifiers
	      from being incremented.
	_EOF_
}

sver_json() {
  local version=${1#v}
  echo '{'
  echo "  \"version\": \"${version}\","
  sver_get_major "$version"
  echo "  \"major\": \"${RETURN}\","
  sver_get_minor "$version"
  echo "  \"minor\": \"${RETURN}\","
  sver_get_patch "$version"
  echo "  \"patch\": \"${RETURN}\","
  sver_get_prerelease "$version"
  echo "  \"prerelease\": \"${RETURN}\","
  sver_get_build_metadata "$version"
  echo "  \"build_metadata\": \"${RETURN}\""
  echo '}'
  RETURN=
}

sver_sort() { # no arg, input is list of semvers, output is via stdout
  local i j swapped tmp versions

  read -a versions <<< $(sver_filter | xargs echo)
  # bubble sort
  for (( i=0 ; i < ${#versions[@]} - 1; i++ )) ; do 
    swapped=false
    for (( j=0 ;  j < ${#versions[@]} - 1 - i ; j++ )) ; do
      if sver_greater_than "${versions[$j]}" "${versions[$((j + 1))]}" ; then
        tmp=${versions[$((j + 1))]} 
        versions[$((j + 1))]=${versions[$j]}
        versions[$j]=$tmp
        swapped=true
      fi
    done
    $swapped || break
  done

  tmp=$IFS
  IFS="
"
  echo "${versions[*]}"
  IFS=$tmp
  RETURN=
}

sver_validate() {
  RETURN=
  [[ "$1" =~ $SVER_REGEX ]]
}

sver_version() {
  RETURN="$SVER_VERSION"
}

sver_yaml() {
  local version=${1#v}
  echo "version: ${version}"
  sver_get_major "$version"
  echo "major: $RETURN"
  sver_get_minor "$version"
  echo "minor: $RETURN"
  sver_get_patch "$version"
  echo "patch: $RETURN"
  sver_get_prerelease "$version"
  echo "prerelease: $RETURN"
  sver_get_build_metadata "$version"
  echo "build_metadata: $RETURN"
  RETURN=
}

# CLI handler; translates CLI args to function calls when used in CLI mode
#
# Instead of hardcoding a mapping of CLI args => functions, leverage the
# existing command completion function to allow for abbreviated commands
# with comprehensive validation and meaningful error messages & hints.
# - `sver b ma v1.2.3` expands to `sver bump major v1.2.3`
# - `sver b m v1.2.3` meaningfully errors due to ambiguous 'm'
#
if [ "$sver_execed" = true ] ; then
  unset command
  if [ $# = 0 ] ; then
    COMP_WORDS=("" "help")
  else
    COMP_WORDS=("" "${@}")
  fi
  COMP_CWORD=1
  _sver_complete_function
  if [ "${#COMPREPLY[@]}" == 1 ] ; then
    shift || true
    command=$COMPREPLY
  else
    if [ "${#COMPREPLY[@]}" == 0 ] ; then
      echo "Error: Unknown command (${COMP_WORDS[1]}), run \"sver help\" for usage."
    else
      echo "Error: Ambiguous command (possibilities: [${COMPREPLY[@]}])."
    fi
    exit 1
  fi
  if [ "$command" = "get" ] || [ "$command" = "bump" ] ; then
    COMP_WORDS=("" "$command" "${@}")
    COMP_CWORD=2
    shift || true
    _sver_complete_function
    if [ "${#COMPREPLY[@]}" == 1 ] ; then
      command="${command}_${COMPREPLY}"
    else
      if [ "${#COMPREPLY[@]}" == 0 ] ; then
        echo "Error: Unknown subcommand (${command} ${COMP_WORDS[2]}), run \"sver help\" for usage."
      else
        echo "Error: Ambiguous subcommand (possibilities: ${command} [${COMPREPLY[@]}])."
      fi
      exit 1
    fi
  fi
  case "$command" in
    bump_*|constraint|get_*|greater_than|json|yaml)
      if ! sver_validate "$1" ; then
        echo "Error: Invalid semver specified (${1})."
        exit 1
      fi
      ;;
  esac
  case "$command" in
    equals|greater_than)
      if ! sver_validate "$2" ; then
        echo "Error: Invalid semver specified (${2})."
        exit 1
      fi
      ;;
  esac

  status=0
  if [ "$command" = constraint ] ; then
    version=$1
    shift
    eval sver_${command} "$version" \""${@}"\" || status=$?
  else
    eval sver_${command} "${@}" || status=$?
  fi

  if [ -n "$RETURN" ] ; then
    echo "$RETURN"
  fi
  exit $status
fi
